---
title: "MC"
author: "Jessica Reyes"
date: "2025-11-23"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(MASS)
library(pROC)
library(dplyr)
```

```{r}

simulate_logit <- function(N, P, rho, beta_pattern) {
  
  # Predictor distribution 
  # Correlation = rho (0 or 0.5)
  Sigma <- matrix(rho, P, P)
  diag(Sigma) <- 1
  
  X <- mvrnorm(n = N, mu = rep(0, P), Sigma = Sigma)
  
  # Predictor effects 
  if (beta_pattern == "equal") {
    beta <- rep(0.5, P)
    
  } else if (beta_pattern == "strong") {
    beta <- c(1.0, rep(0.2, P-1))      # 1 strong effect
    
  } else if (beta_pattern == "noise") {
    beta <- c(0, rep(0.3, P-1))        # first predictor is noise
    
  } else if (beta_pattern == "halfnoise") {
    beta <- c(rep(0, P/2), rep(0.3, P/2))  # first half noise
  
  } else {
    stop("Unknown beta pattern")
  }
  
  # Linear predictor + logistic link
  eta <- X %*% beta
  pi  <- 1/(1 + exp(-eta))
  
  # Binary outcome from Bernoulli
  y <- rbinom(N, size = 1, prob = pi)
  
  data.frame(y = y, X)
}

```

```{r}
fit_logistic_mle <- function(dat) {
  glm(y ~ ., data = dat, family = binomial)
}

```

```{r}
evaluate_model <- function(fit, dat) {
  
  probs <- predict(fit, type = "response")
  
  auc_val <- auc(dat$y, probs)
  brier <- mean((dat$y - probs)^2)
  
  tibble::tibble(
    # AUC: Area Under the ROC Curve
    AUC = as.numeric(auc_val),
    # brier: measure of the accuracy of probabilistic predictions
    Brier = brier
  )
}

```

```{r}
P_vals <- c(4, 8, 12)
rho_vals <- c(0, 0.5)
beta_patterns <- c("equal", "strong", "noise", "halfnoise")

results <- list()
iter <- 1

for (P in P_vals) {
  for (rho in rho_vals) {
    for (bp in beta_patterns) {
      
      # One simulation run
      dat <- simulate_logit(N = 1000, P = P, rho = rho, beta_pattern = bp)
      
      # Maximum likelihood fit
      fit <- fit_logistic_mle(dat)
      
      # Evaluate predictive performance
      perf <- evaluate_model(fit, dat)
      
      # Save results
      results[[iter]] <- cbind(
        P = P,
        rho = rho,
        beta_pattern = bp,
        perf
      )
      
      iter <- iter + 1
    }
  }
}

final_results <- bind_rows(results)
knitr::kable(final_results)

```

```{r}
roc_obj <- roc(dat$y, predict(fit, type="response"))
plot(roc_obj, col="rosybrown", lwd=2)

```


```{r}
library(ggplot2)

cal_df <- dat %>%
  mutate(prob = predict(fit, type="response"),
         decile = ntile(prob, 10)) %>%
  group_by(decile) %>%
  summarize(obs = mean(y), pred = mean(prob))

ggplot(cal_df, aes(pred, obs)) +
  geom_point(size = 3) +
  geom_line() +
  geom_abline(slope = 1, intercept = 0, color = "yellow4", lty = 2) +
  ylim(0,1) + xlim(0,1) +
  ggtitle("Calibration Plot")

```

